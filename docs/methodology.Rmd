---
title: "Methodology and Error in Individual Urine Samples"
author: "Tecla Duran Fort"
date: "`r Sys.Date()`"
output:
  github_document:
    toc: true
    toc_depth: 3
    md_extensions: +raw_html
  pdf_document:
    toc: yes
    toc_depth: 3
  html_document:
    toc: yes
    toc_depth: 3
    number_sections: false
always_allow_html: true
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE, 
  fig.align='center'
)

library(dplyr)
library(ggplot2)
library(tibble)
library(patchwork)
library(tidyr)
library(rprojroot)
knitr::opts_knit$set(root.dir = rprojroot::find_root(rprojroot::is_git_root))

source("../load_harmonization_tools.R")

doc_colors <- c("navy", "#E0711A")


analyte_colors <- c("anisole"=doc_colors[1],"heptanone"=doc_colors[2])


model_colors <- c(
  "Baseline" = doc_colors[1],
  "Proposed" = doc_colors[2]
)

model_shapes <- c(
  "Baseline" = 16,
  "Proposed" = 17
)

```
\newpage

# Load Data

```{r}
path <- "../data/tables"

files <- list.files(path, pattern = "\\.csv$", full.names = TRUE)

for (f in files) {
  name <- tools::file_path_sans_ext(basename(f))
  assign(name, read.csv(f))
}
```

```{r}
analytes = c("anisole", "heptanone")
```


# Calibration Curves

## Reference Polynomial Adjustment to Enforce Origin Constraint

```{r}
su <- shift_to_origin(su, analytes)$data
```

```{r}
# Individual Tables

for (a in analytes) {
  
  # Subset SU: concentration column is specific for each analyte
  su_df <- su %>%
    dplyr::select(
      concentration = dplyr::all_of(paste0("c_", a)),
      intensity     = dplyr::all_of(a)
    )
  
  # Subset POOL: a single concentration column and an intensity column per analyte
  pool_df <- pool %>%
    dplyr::select(
      concentration,
      intensity = dplyr::all_of(a)
    )
  
  # Store in the global environment as su_analyte and pool_analyte
  assign(paste0("su_", a),   su_df,   envir = .GlobalEnv)
  assign(paste0("pool_", a), pool_df, envir = .GlobalEnv)
}

str(su_anisole)
str(pool_anisole)
```

## Polynomial Fit

```{r}
res_poly <- fit_polynomials(su, c("anisole", "heptanone"))

coef_poly <- res_poly$coef_table
metrics_poly <- res_poly$metrics_table
models_list <- res_poly$models
```

```{r, fig.height=4, fig.width=5}
plot_polynomial_fits(su, models_list)
```

```{r, echo=FALSE}
plots_poly <- plot_polynomial_fits(su, models_list)

p1 <- plots_poly[[1]]  # Anisole
p2 <- plots_poly[[2]]  # Heptanone

ggsave(
  filename = file.path("figures", "polynomial_fit_anisole.pdf"),
  plot = p1,
  width = 5,
  height = 4,
  device = cairo_pdf
)

ggsave(
  filename = file.path("figures", "polynomial_fit_heptanone.pdf"),
  plot = p2,
  width = 5,
  height = 4,
  device = cairo_pdf
)
```

```{r}
coef_poly %>%
  knitr::kable(
    caption = "Polynomial coefficients (degree 3, no intercept)",
    digits = 4,
    col.names = c("Analyte", "a0", "a1", "a2", "a3"),
    align = "lcccc"
  ) %>%
  kableExtra::kable_styling(full_width = FALSE, position = "center")

# Mostrar taula de mètriques
metrics_poly %>%
  knitr::kable(
    caption = "Model fit metrics",
    digits = 4,
    col.names = c("Analyte", "R²", "Adjusted R²", "RSE", "RSS"),
    align = "lcccc"
  ) %>%
  kableExtra::kable_styling(full_width = FALSE, position = "center")

```


```{r}
equations_table <- coef_poly %>%
  mutate(
    Equation = sprintf(
      "f(C) = %.3f·C + %.3f·C² + %.3f·C³",
      a1, a2, a3
    )
  ) %>%
  select(Analyte, Equation)
equations_table %>%
  knitr::kable(
    caption = "Polynomial equations",
    col.names = c("Analyte", "Equation"),
    align = "l",
    digits = 4
  ) %>%
  kableExtra::kable_styling(full_width = FALSE, position = "center")
```
# Harmonization

## Anisole

```{r, echo=TRUE}
res_anisole <- harmonize(pool_anisole, su_anisole)
```

```{r}
# Create summary table
summary_anisole <- tibble::tibble(
Parameter = c("Scale", "Shift"),
Value     = c(
round(res_anisole$scale,  3),
round(res_anisole$shift,  3)
),
Error     = c(
paste0("±", round(res_anisole$scale_error, 3)),
paste0("±", round(res_anisole$shift_error, 3))
),
Units = c("–", "ppb")
)

knitr::kable(
summary_anisole,
caption = "Harmonization parameters and uncertainty (Anisole)",
align = "c"
)

```

```{r, fig.height=4, fig.width=6, fig.align='center'}
plot_harmonization(res_anisole, title = "Calibration Harmonization - Anisole")
```

### Final Calibration Curve

Calibration curves without harmonization (baseline model) and with pool harmonization (proposed model).

```{r}
calibration_anisole <- tibble(
  concentration_original   = res_anisole$su_grid$concentration,
  concentration_harmonized = res_anisole$su_grid_trans$concentration + res_anisole$shift,
  intensity                = res_anisole$su_grid_trans$intensity
)
```

```{r, fig.width=4, fig.height=3, fig.align='center', echo=FALSE}
p <- ggplot(calibration_anisole) +
  geom_line(aes(x = concentration_harmonized, y = intensity, color = "Harmonized"),
            linewidth = 1.2) +
  geom_line(aes(x = concentration_original, y = intensity, color = "Original"),
            linewidth = 1.2, linetype = "dashed") +
  scale_color_manual(values = c("Harmonized" = "navy", "Original" = "#E0711A")) +
  labs(
    title = "Calibration Curves - Anisole",
    x = "Concentration (ppb)",
    y = "Intensity"
  ) +
  theme_minimal(base_size = 10) +
  theme(legend.position = "bottom")

p

```

```{r}
ggsave(
  filename = file.path("figures", "calibration_curves_anisole.pdf"),
  plot = p,
  width = 4,
  height = 3,
  device = cairo_pdf
)
```


## Heptanone

```{r, echo=TRUE}
res_heptanone <- harmonize(pool_heptanone, su_heptanone)
```

```{r}
# Create summary table
summary_hept <- tibble::tibble(
Parameter = c("Scale", "Shift"),
Value     = c(
round(res_heptanone$scale,  3),
round(res_heptanone$shift,  3)
),
Error     = c(
paste0("±", round(res_heptanone$scale_error, 3)),
paste0("±", round(res_heptanone$shift_error, 3))
),
Units = c("–", "ppb")
)

knitr::kable(
summary_hept,
caption = "Harmonization parameters and uncertainty (Heptanone)",
align = "c"
)

```

```{r, fig.height=4, fig.width=6, echo=TRUE}
plot_harmonization(res_heptanone, title = "Calibration Harmonization - 2- Heptanone")
```


### Final Calibration Curves

Calibration curves without harmonization (baseline model) and with pool harmonization (proposed model).

```{r}
calibration_heptanone <- tibble(
  concentration_original   = res_heptanone$su_grid$concentration,
  concentration_harmonized = res_heptanone$su_grid_trans$concentration + res_heptanone$shift,
  intensity                = res_heptanone$su_grid_trans$intensity
)

```

```{r}
p<- ggplot(calibration_heptanone) +
  
  # Harmonized (navy)
  geom_line(
    aes(
      x = concentration_harmonized,
      y = intensity,
      color = "Harmonized"
    ),
    linewidth = 1.2
  ) +
  
  # Original (orange)
  geom_line(
    aes(
      x = concentration_original,
      y = intensity,
      color = "Original"
    ),
    linewidth = 1.2,
    linetype = "dashed"
  ) +
  
  scale_color_manual(
    name = "",
    values = c("Harmonized" = "navy", "Original" = "#E0711A")
  ) +
  
  labs(
    title = "Calibration Curves - 2-Heptanone",
    x = "Concentration (ppb)",
    y = "Intensity"
  ) +
  
  theme_minimal(base_size = 10) +
  theme(
    plot.title = element_text(size = 11, face = "bold", hjust = .5),
    legend.position = "bottom",
    legend.text = element_text(size = 9)
  )
p
```
```{r}
ggsave(
  filename = file.path("figures", "calibration_curves_heptanone.pdf"),
  plot = p,
  width = 4,
  height = 3,
  device = cairo_pdf
)
```


## Extrapolation 

```{r}
extra_anisole <- extrapolate_curve(calibration_anisole)
extra_heptanone <- extrapolate_curve(calibration_heptanone)

```

```{r, fig.height=4, fig.width=5}
plot_extrapolated_curve(extra_anisole, "Extended Calibration Curve - Anisole")

```

```{r, fig.height=4, fig.width=5}
plot_extrapolated_curve(extra_heptanone, "Extended Calibration Curve - 2-Heptanone")
```

```{r}
calibration_anisole   <- extra_anisole$full
calibration_heptanone <- extra_heptanone$full

calibration_table <- list(
  anisole = calibration_anisole,
  heptanone = calibration_heptanone
)

```

# Concentration Prediction 


## Prediction Without Scaling the Curve (Baseline)

```{r concentration-prediction}
datasets <- c("pool", "s1", "s2", "s3", "s4")

concentrations_baseline <- data.frame()

for (sample_name in datasets) {
  df_sample <- get(sample_name)
  
  for (analyte in analytes) {
    
    calib <- calibration_table[[analyte]]
    
    conc <- interpolate_concentration(
      intensity = df_sample[[analyte]],
      calibration_intensity = calib$intensity,
      calibration_concentration = calib$concentration_original
    )
    
    df_tmp <- df_sample %>%
      mutate(
        int = .data[[analyte]],
        conc_estimated = conc,
        Sample = sample_name,
        Analyte = analyte
      ) %>%
      select(SampleID, Sample, Analyte, concentration, int, conc_estimated)
    
    concentrations_baseline <- bind_rows(concentrations_baseline, df_tmp)
  }
}

concentrations_baseline%>% select(-SampleID) %>%
  head(5) %>% 
  knitr::kable(
    caption = "Estimated concentrations across datasets (baseline calibration)",
    col.names = c("Sample", "Analyte", "Spiked Conc. (ppb)",
                  "Intensity (a.u.)", "Estimated Conc. (ppb)"),
    digits = 4,
    align = "lccrr"
  ) %>%
  kableExtra::kable_styling(full_width = FALSE, position = "center")

```

## Prediction Scaling the Curve (Proposed Method)

```{r concentration-prediction-prop}
concentrations <- data.frame()

for (sample_name in datasets) {
  df_sample <- get(sample_name)
  
  for (analyte in analytes) {
    
    calib <- calibration_table[[analyte]]
    
    conc <- interpolate_concentration(
      intensity = df_sample[[analyte]],
      calibration_intensity = calib$intensity,
      calibration_concentration = calib$concentration_harmonized
    )
    
    df_tmp <- df_sample %>%
      mutate(
        int = .data[[analyte]],
        conc_estimated = conc,
        Sample = sample_name,
        Analyte = analyte
      ) %>%
      select(SampleID, Sample, Analyte, concentration, int, conc_estimated)
    
    concentrations <- bind_rows(concentrations, df_tmp)
  }
}

concentrations %>% select(-SampleID) %>%
  head(5) %>% 
  knitr::kable(
    caption = "Estimated concentrations across datasets (proposed calibration)",
    col.names = c("Sample", "Analyte", "Spiked Conc. (ppb)",
                  "Intensity (a.u.)", "Estimated Conc. (ppb)"),
    digits = 4,
    align = "lccrr"
  ) %>%
  kableExtra::kable_styling(full_width = FALSE, position = "center")

```


# Error Calculation


## Anisole (Non-Endogenous)


In this section we evaluate the accuracy of the estimated concentrations obtained from the calibration models.  
For each measurement we define the **error** as:

$$
\varepsilon_i = \widehat{C}_i - C_i,
$$

where  
- \(C_i\) = true (spiked) concentration, since anisole is non endogenous analyte  
- \(\widehat{C}_i\) = estimated concentration from the calibration model.

To summarise the error magnitude we use the **root-mean-square error (RMSE)**:

\[
\mathrm{RMSE}
  = \sqrt{\frac{1}{n} \sum_i (\,\widehat{C}_i - C_i\,)^2 }.
\]

RMSE gives a single value (in ppb) that increases when predictions deviate from the true concentration.  
We compare RMSE between:

- **Baseline model** (using the original SU calibration curve)  
- **Proposed model** (using the harmonised and scaled calibration curve)

for:
- Pool sample  
- Individual samples (s1–s3, s4)  
- Global error across all samples  
- Each concentration level  

The following tables and plots present these comparisons.


```{r}
df_baseline <- concentrations_baseline %>%
  filter(Analyte == "anisole") %>%
  mutate(
    error = conc_estimated - concentration,
    Method = "Baseline"
  )

df_proposed <- concentrations %>%
  filter(Analyte == "anisole") %>%
  mutate(
    error = conc_estimated - concentration,
    Method = "Proposed"
  )

df_error_a <- bind_rows(df_baseline, df_proposed)
```

### RMSE in Pool

```{r}
df_pool <- df_error_a %>% filter(Sample == "pool")

rmse_pool <- df_pool %>%
  group_by(Method) %>%
  summarise(
    RMSE = sqrt(mean(error^2, na.rm = TRUE)),
    .groups = "drop"
  )

rmse_pool %>%
  knitr::kable(
    caption = "RMSE in pool (anisole)",
    col.names = c("Method", "RMSE (ppb)")
  ) %>%
  kableExtra::kable_styling(full_width = FALSE)
```


### RMSE in Individual Samples

```{r}
rmse_global <- df_error_a %>%
  filter(Sample %in% c("s1","s2","s3","s4")) %>%
  group_by(Method) %>%
  summarise(
    RMSE = sqrt(mean(error^2, na.rm = TRUE)),
    .groups = "drop"
  )

rmse_global %>%
  knitr::kable(
    caption = "Global RMSE (anisole)",
    col.names = c("Method", "RMSE (ppb)")
  ) %>%
  kableExtra::kable_styling(full_width = FALSE)
```

### RMSE vs Concentration Level

```{r}
rmse_levels <- df_error_a %>%
  filter(Sample %in% c("s1","s2","s3","s4"))%>%
  group_by(Method, concentration) %>%
  summarise(
    RMSE = sqrt(mean(error^2, na.rm = TRUE)),
    .groups = "drop"
  )

```

```{r, fig.height=4, fig.width=5}
p <- ggplot(rmse_levels, aes(x = concentration, y = RMSE, color = Method)) +
  geom_point(size = 3) +
  geom_line(size = 1) +
  scale_color_manual(values = model_colors) +
  labs(
    title = "RMSE vs Concentration (Anisole)",
    x = "True Concentration (ppb)",
    y = "RMSE (ppb)"
  ) +
  theme_minimal(base_size = 10) +
  theme(legend.position = "bottom")

ggsave(
  filename = file.path("figures", "rmse_vs_concentration_anisole.pdf"),
  plot = p,
  width = 5,
  height = 4,
  device = cairo_pdf
)

p

```

### Predicted vs True Concentration

```{r}
df_plot <- df_error_a%>%
  filter(Sample %in% c("s1","s2","s3","s4")) %>%
  mutate(
    conc_true = concentration,
    conc_pred = conc_estimated
  )

p <- ggplot(df_plot, aes(x = conc_true, y = conc_pred,
                         color = Method, shape = Method)) +
  geom_point(size = 2.8, alpha = 0.85) +
  geom_abline(slope = 1, intercept = 0,
              linetype = "dashed", linewidth = 0.8) +
  scale_color_manual(values = model_colors) +
  scale_shape_manual(values = model_shapes) +
  labs(
    title = "Predicted vs True Concentration (Anisole)",
    x = "True (ppb)",
    y = "Predicted (ppb)"
  ) +
  theme_minimal(base_size = 10) +
  theme(legend.position = "bottom")

ggsave(
  filename = file.path("figures", "predicted_vs_true_anisole.pdf"),
  plot = p,
  width = 5,
  height = 4,
  device = cairo_pdf
)

p

```

## 2-Heptanone (Endogenous)

Unlike anisole, **2-heptanone is naturally present** in urine without spiking.  
Therefore, to compute the prediction error, we must estimate the **endogenous (baseline) concentration** \(C_0\) for each sample.

We treat each sample as a shifted version of the SU calibration curve.  
Using the affine alignment model:

$$
f_{\text{sample}}(C_{\text{total}}) \approx f_{\text{SU}}\!\left(\alpha \cdot C_{\text{total}}\right),
$$

we obtain:

- \(C_0\): endogenous concentration (offset)
- \(\alpha\): scale factor due to matrix effects

The **true concentration** for each point becomes:

$$
C_{\text{total}} = C + C_0
$$

All RMSE calculations use this corrected concentration.



### Endogenous Concentration Estimation 

```{r}
analyte <- "heptanone"

samples <- c("pool", "s1", "s2", "s3", "s4")
table_endogenous <- data.frame()
df_total_h <- data.frame()

for (s in samples) {
  
  df_sample <- get(s) %>%
    select(
      concentration,
      intensity     = !!sym(analyte)
    )
  
  res <- harmonize(
    df_target   = df_sample,
    df_sub      = su_heptanone
  )
  
  table_endogenous <- rbind(
    table_endogenous,
    data.frame(
      Sample   = s,
      Analyte  = analyte,
      C0_ppb   = round(res$shift, 3),
      C0_error = round(res$shift_error, 3)
    )
  )
  
}

knitr::kable(
  table_endogenous,
  caption = "Estimated endogenous concentrations (2-Heptanone)",
  col.names = c("Sample","Analyte","C0 (ppb)","Error")
) %>%
  kableExtra::kable_styling(full_width = FALSE)

```


### Error Calculation

*Same RMSE approach as anisole, but using total concentration.*

```{r}

# Extract endogenous shifts per sample
df_shifts_h <- table_endogenous %>%
  select(Sample, C0_ppb)

# Baseline
df_baseline_h <- concentrations_baseline %>%
  filter(Analyte == "heptanone") %>%
  left_join(df_shifts_h, by = "Sample") %>%
  mutate(
    conc_hept_total = concentration + C0_ppb,
    error           = conc_estimated - conc_hept_total,
    Method          = "Baseline"
  )

# Proposed
df_proposed_h <- concentrations %>%
  filter(Analyte == "heptanone") %>%
  left_join(df_shifts_h, by = "Sample") %>%
  mutate(
    conc_hept_total = concentration + C0_ppb,
    error           = conc_estimated - conc_hept_total,
    Method          = "Proposed"
  )

# Combined
df_error_h <- bind_rows(df_baseline_h, df_proposed_h)

```


### RMSE in pool

```{r}
rmse_pool_h <- df_error_h %>%
  filter(Sample == "pool") %>%
  group_by(Method) %>%
  summarise(
    RMSE = sqrt(mean(error^2, na.rm=TRUE)),
    .groups="drop"
  )

knitr::kable(
  rmse_pool_h,
  caption = "RMSE in pool (2-Heptanone)",
  col.names = c("Method","RMSE (ppb)")
) %>% kableExtra::kable_styling(full_width = FALSE)
```

### RMSE in Individual Samples

```{r}
rmse_global_h <- df_error_h %>%
  filter(Sample %in% c("s1","s2","s3","s4")) %>%
  group_by(Method) %>%
  summarise(
    RMSE = sqrt(mean(error^2, na.rm=TRUE)),
    .groups="drop"
  )

knitr::kable(
  rmse_global_h,
  caption = "Global RMSE (2-Heptanone)",
  col.names = c("Method","RMSE (ppb)")
) %>% kableExtra::kable_styling(full_width = FALSE)
```

### RMSE vs Concentration Level 
*Grouped by spiked concentration*

```{r, fig.height=4, fig.width=5}
rmse_levels_h <- df_error_h %>%
  filter(Sample %in% c("s1","s2","s3","s4"))%>%
  group_by(Method, concentration) %>%  
  summarise(
    RMSE = sqrt(mean(error^2, na.rm=TRUE)),
    SD = sd(error, na.rm=TRUE),
    .groups = "drop"
  )

p <- ggplot(rmse_levels_h, aes(x = concentration, y = RMSE, color = Method)) +
  geom_point(size = 3) +
  geom_line(size = 1) +
  geom_errorbar(aes(ymin = RMSE - SD, ymax = RMSE + SD), width = 0.2) +
  scale_color_manual(values = model_colors) +
  labs(
    title = "RMSE vs Spike Concentration (2-Heptanone)",
    x = "Nominal Spike (ppb)",
    y = "RMSE (ppb)"
  ) +
  theme_minimal(base_size = 10)

ggsave(
  filename = file.path("figures", "rmse_vs_concentration_heptanone.pdf"),
  plot = p,
  width = 5,
  height = 4,
  device = cairo_pdf
)

p

```



### Predicted vs True (Total) Concentration

```{r}
df_plot_h <- df_error_h %>%
  filter(Sample %in% c("s1","s2","s3","s4")) %>%
  mutate(
    conc_true = conc_hept_total,
    conc_pred = conc_estimated
  )

p <- ggplot(df_plot_h, aes(x = conc_true, y = conc_pred,
                           color = Method, shape = Method)) +
  geom_point(size = 2.8, alpha = 0.85) +
  geom_abline(slope = 1, intercept = 0,
              linetype = "dashed", linewidth = 0.8) +
  scale_color_manual(values = model_colors) +
  scale_shape_manual(values = model_shapes) +
  labs(
    title = "Predicted vs True Total Concentration (2-Heptanone)",
    x = "True Total (ppb)",
    y = "Predicted (ppb)"
  ) +
  theme_minimal(base_size = 10) +
  theme(legend.position = "bottom")

ggsave(
  filename = file.path("figures", "predicted_vs_true_heptanone.pdf"),
  plot = p,
  width = 5,
  height = 4,
  device = cairo_pdf
)

p
```

```{r}
# -------UNIFIED TABLE WITH ALL PREDICTIONS ---------
df_C0 <- table_endogenous %>%
  select(
    Sample,
    Analyte,
    Estimated_C0 = C0_ppb,
    Estimated_C0_error = C0_error
  )

df_base <- concentrations_baseline %>%
  left_join(df_C0, by = c("Sample", "Analyte")) %>%
  mutate(
    Estimated_C0 = ifelse(is.na(Estimated_C0), 0, Estimated_C0),
    Estimated_C0_error = ifelse(is.na(Estimated_C0_error), 0, Estimated_C0_error),
    total_concentration = concentration + Estimated_C0
  ) %>%
  select(
    SampleID,
    Sample,
    Analyte,
    spiked_concentration = concentration,
    Estimated_C0,
    Estimated_C0_error,
    total_concentration,
    intensity = int,
    predicted_baseline = conc_estimated
  )

df_prop <- concentrations %>%
  left_join(df_C0, by = c("Sample", "Analyte")) %>%
  mutate(
    Estimated_C0 = ifelse(is.na(Estimated_C0), 0, Estimated_C0),
    Estimated_C0_error = ifelse(is.na(Estimated_C0_error), 0, Estimated_C0_error)
  ) %>%
  select(
    SampleID,
    Sample,
    Analyte,
    predicted_proposed = conc_estimated
  )


final_table <- df_base %>%
  left_join(
    df_prop,
    by = c("SampleID", "Sample", "Analyte")
  ) %>%
  arrange(Analyte, Sample, spiked_concentration)

final_table <- final_table %>%
  mutate(
    error_baseline = predicted_baseline - total_concentration,
    error_proposed = predicted_proposed - total_concentration,
    abs_error_baseline = abs(error_baseline),
    abs_error_proposed = abs(error_proposed)
  )

```


## Model Comparison 

### Statistical test

Wilcoxon paired test

**ANISOLE**

```{r}
df_anisole <- final_table %>%
  filter(Analyte == "anisole")

wilcox_anisole <- wilcox.test(
  df_anisole$abs_error_baseline,
  df_anisole$abs_error_proposed,
  paired = TRUE,
  exact  = FALSE
)

wilcox_anisole

```

**HEPTANONE**

```{r}
df_heptanone <- final_table %>%
  filter(Analyte == "heptanone")

wilcox_heptanone <- wilcox.test(
  df_heptanone$abs_error_baseline,
  df_heptanone$abs_error_proposed,
  paired = TRUE,
  exact  = FALSE
)

wilcox_heptanone

```
```{r}
wilcox_results <- tibble::tibble(
  Analyte = c("Anisole", "2-Heptanone"),
  Test = "Wilcoxon signed-rank (paired)",
  V_statistic = c(
    wilcox_anisole$statistic,
    wilcox_heptanone$statistic
  ),
  P_value = c(
    wilcox_anisole$p.value,
    wilcox_heptanone$p.value
  )
) %>%
  mutate(
    Interpretation = ifelse(
      P_value < 0.05,
      "Significant difference between models",
      "No significant difference between models"
    )
  )

wilcox_results %>%
  knitr::kable(
    caption = "Paired Wilcoxon signed-rank test on absolute errors (Baseline vs Proposed)",
    digits = 4,
    align = "lcccc"
  ) %>%
  kableExtra::kable_styling(
    full_width = FALSE,
    position = "center"
  )

```
A paired Wilcoxon signed-rank test was applied to the absolute prediction errors obtained with the baseline and proposed calibration models, pairing measurements by SampleID.
For anisole, a statistically significant difference was observed (V = 4558, p = 5.2e-05), indicating a clear reduction in error when using the proposed harmonised calibration.
In contrast, no significant difference was found for 2-heptanone (V = 3228, p = 0.85), suggesting that the proposed method does not provide a measurable improvement over the baseline model for this endogenous compound.


```{r}
df_long <- final_table %>%
  pivot_longer(
    cols = c(abs_error_baseline, abs_error_proposed),
    names_to  = "Method",
    values_to = "AbsError"
  ) %>%
  mutate(
    Method = recode(
      Method,
      abs_error_baseline = "Baseline",
      abs_error_proposed = "Proposed"
    )
  )

```
```{r}
ggplot(
  df_long %>% filter(Analyte == "anisole"),
  aes(x = Method, y = AbsError, fill = Method)
) +
  geom_boxplot(width = 0.5, outlier.shape = NA, alpha = 0.6) +
  scale_fill_manual(values = model_colors) +
  labs(
    title = "Absolute Error Distribution (Anisole)",
    y = "Absolute error (ppb)",
    x = ""
  ) +
  theme_minimal(base_size = 10) +
  theme(
    legend.position = "none",
    plot.title = element_text(hjust = 0.5, face = "bold")
  )

```


```{r}
ggplot(
  df_long %>% filter(Analyte == "heptanone"),
  aes(x = Method, y = AbsError, fill = Method)
) +
  geom_boxplot(width = 0.5, outlier.shape = NA, alpha = 0.6) +
  scale_fill_manual(values = model_colors) +
  labs(
    title = "Absolute Error Distribution (2-Heptanone)",
    y = "Absolute error (ppb)",
    x = ""
  ) +
  theme_minimal(base_size = 10) +
  theme(
    legend.position = "none",
    plot.title = element_text(hjust = 0.5, face = "bold")
  )

```

## Discussion

The error is lower with our methodology in anisole but not in heptanone. 
This is probably due to the fact that the effect of the matrix is lower for 2-heptanone. 

Since we have a whole calibration for each individual sample, we can estimate the scale wrt the synthetic urine. 

```{r}
samples  <- c("pool","s1","s2","s3","s4")
analytes <- c("anisole","heptanone")

scale_table <- data.frame()

for (sample in samples) {
  
  df_target <- get(sample)
  
  for (an in analytes) {
    
    df_su  <- su %>% select(concentration, intensity = !!sym(an))
    df_tar <- df_target %>% select(concentration, intensity = !!sym(an))
    
    res <- harmonize(df_tar, df_su)
    
    scale_table <- rbind(
      scale_table,
      data.frame(
        Sample      = sample,
        Analyte     = an,
        Scale       = res$scale,
        Scale_error = res$scale_error
      )
    )
  }
}

```

```{r}
library(knitr)

scale_table %>%
  mutate(
    Scale_fmt = sprintf("%.3f ± %.3f", Scale, Scale_error)
  ) %>%
  select(Sample, Analyte, Scale_fmt) %>%
  kable(
    format = "simple",
    col.names = c("Sample", "Analyte", "Scale ± Error"),
    align = "ccc",
    caption = "Estimated scaling factors with uncertainty"
  )

```


```{r, fig.height=4, fig.width=9}
make_plot <- function(analyte){

  df <- scale_table %>% filter(Analyte == analyte)

  # Pool values
  scale_pool  <- df %>% filter(Sample=="pool") %>% pull(Scale)
  error_pool  <- df %>% filter(Sample=="pool") %>% pull(Scale_error)

  # other samples
  df_plot <- df %>% filter(Sample!="pool")

  ggplot(df_plot, aes(Sample, Scale)) +

    # Ribbon for pool uncertainty
    geom_rect(aes(xmin = -Inf, xmax = Inf,
                  ymin = scale_pool - error_pool,
                  ymax = scale_pool + error_pool),
              fill = analyte_colors[analyte],
              alpha = 0.05,
              inherit.aes = FALSE) +

    # Reference line y=1
    geom_hline(yintercept = 1, color="grey40", linewidth=0.8) +

    # Dashed line for pool scale
    geom_hline(yintercept = scale_pool,
               color = analyte_colors[analyte],
               linewidth = 0.8, linetype = "dashed") +

    # Error bars for sample estimates
    geom_errorbar(aes(ymin = Scale - Scale_error,
                      ymax = Scale + Scale_error),
                  width = 0.15,
                  color = analyte_colors[analyte]) +

    # Points
    geom_point(color = analyte_colors[analyte], size = 4) +

    labs(subtitle = display_name(analyte),
         x = "Sample", y = "Scale") +

    theme_minimal(base_size = 10) +
    theme(
      plot.subtitle = element_text(face = "bold", hjust = 0.5)
    )
}

p1 <- make_plot("anisole")
p2 <- make_plot("heptanone")


p <- p1 + p2 +
  plot_annotation(
    title = "Scaling Factors for All Samples",
    subtitle = "Dashed line = Pool scale",
    theme = theme(
      plot.title = element_text(
        face = "bold",
        hjust = 0.5
      ),
      plot.subtitle = element_text(
        hjust = 0.5
      )
    )
  )


ggsave(
  filename = file.path("figures", "scaling_factors_all_samples.pdf"),
  plot = p,
  width = 9,
  height = 4,
  device = cairo_pdf
)

p

```


For anisole, the individual samples deviate more from the pool reference, while for 2-heptanone the scaling factors stay much closer to 1 (synthetic urine), indicating that matrix effects are smaller and the harmonization may not be necessary or helpful in this case. 

